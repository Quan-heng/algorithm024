学习笔记
## 1.树、二叉树，二叉搜索树的实现和特性。时间复杂度n(logn)
* 查询（递归->深度优先，跌代->广度优先）
* 删除-->选右子树里值最接近他的结点（也就是右子树里最小的结点）做为它的替换结点。

## 2.堆和二叉堆
堆（可以迅速找到一堆数中的最大或者最小值的数据结构）通过完全二叉树实现（注意：不是二叉搜索树；
二叉堆（大项）它满足下列性质：

* [性质一] 是一棵完全树。
* [性质二]树中任意节点的值总是>=其子节点的值
* [记忆]
* 0.根节点（顶堆元素）是：a[0]
* 1.索引为i的左孩子的索引是（2*i+1）;
* 2.索引为i的右孩子的索引是（2*i+2）;
* 3.索引为i的父结点的索引是 floor((i-1)/2)

* [Insert插入操作]HeapifyUp
    * 1.新元素一律先插入到堆的尾部
    * 2.依次向上调整整个堆的结构（一直到根即可）

* [Delete max删除堆顶操作的] HeapifyDown
* 1.将堆尾元素替换到顶部（即对顶被替代删除掉）
* 2.依次从根部向下调整整个堆的结构（一直到堆尾即可）

* 掌握：
    * 1.理解堆的实现代码https://shimo.im/docs/Lw86vJzOGOMpWZz2/
    * 2.理解PriorityQueue源码:https://www.cnblogs.com/CarpenterLee/p/5488070.html, 注：默认是小顶堆，poll取出的总是最小元素。
    * 3.LeetCode-最小的K个数，Priorityqueue（小顶堆）, poll前面n个数
    * 4.LeetCode-滑动窗口,方法1（双端队列），方法2（堆）
    * 5.LeetCode-347前k个高频词，PriorityQue, HashMap